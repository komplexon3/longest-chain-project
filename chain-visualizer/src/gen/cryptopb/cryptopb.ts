/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.24.4
 * source: cryptopb/cryptopb.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../contextstorepb/contextstorepb";
import * as dependency_2 from "./../dslpb/dslpb";
import * as dependency_3 from "./../mir/codegen_extensions";
import * as pb_1 from "google-protobuf";
export namespace cryptopb {
    export class Event extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6]];
        constructor(data?: any[] | ({} & (({
            sign_request?: SignRequest;
            sign_result?: never;
            verify_sig?: never;
            sig_verified?: never;
            verify_sigs?: never;
            sigs_verified?: never;
        } | {
            sign_request?: never;
            sign_result?: SignResult;
            verify_sig?: never;
            sig_verified?: never;
            verify_sigs?: never;
            sigs_verified?: never;
        } | {
            sign_request?: never;
            sign_result?: never;
            verify_sig?: VerifySig;
            sig_verified?: never;
            verify_sigs?: never;
            sigs_verified?: never;
        } | {
            sign_request?: never;
            sign_result?: never;
            verify_sig?: never;
            sig_verified?: SigVerified;
            verify_sigs?: never;
            sigs_verified?: never;
        } | {
            sign_request?: never;
            sign_result?: never;
            verify_sig?: never;
            sig_verified?: never;
            verify_sigs?: VerifySigs;
            sigs_verified?: never;
        } | {
            sign_request?: never;
            sign_result?: never;
            verify_sig?: never;
            sig_verified?: never;
            verify_sigs?: never;
            sigs_verified?: SigsVerified;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sign_request" in data && data.sign_request != undefined) {
                    this.sign_request = data.sign_request;
                }
                if ("sign_result" in data && data.sign_result != undefined) {
                    this.sign_result = data.sign_result;
                }
                if ("verify_sig" in data && data.verify_sig != undefined) {
                    this.verify_sig = data.verify_sig;
                }
                if ("sig_verified" in data && data.sig_verified != undefined) {
                    this.sig_verified = data.sig_verified;
                }
                if ("verify_sigs" in data && data.verify_sigs != undefined) {
                    this.verify_sigs = data.verify_sigs;
                }
                if ("sigs_verified" in data && data.sigs_verified != undefined) {
                    this.sigs_verified = data.sigs_verified;
                }
            }
        }
        get sign_request() {
            return pb_1.Message.getWrapperField(this, SignRequest, 1) as SignRequest;
        }
        set sign_request(value: SignRequest) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_sign_request() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get sign_result() {
            return pb_1.Message.getWrapperField(this, SignResult, 2) as SignResult;
        }
        set sign_result(value: SignResult) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_sign_result() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get verify_sig() {
            return pb_1.Message.getWrapperField(this, VerifySig, 3) as VerifySig;
        }
        set verify_sig(value: VerifySig) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_verify_sig() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get sig_verified() {
            return pb_1.Message.getWrapperField(this, SigVerified, 4) as SigVerified;
        }
        set sig_verified(value: SigVerified) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_sig_verified() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get verify_sigs() {
            return pb_1.Message.getWrapperField(this, VerifySigs, 5) as VerifySigs;
        }
        set verify_sigs(value: VerifySigs) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_verify_sigs() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get sigs_verified() {
            return pb_1.Message.getWrapperField(this, SigsVerified, 6) as SigsVerified;
        }
        set sigs_verified(value: SigsVerified) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_sigs_verified() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get type() {
            const cases: {
                [index: number]: "none" | "sign_request" | "sign_result" | "verify_sig" | "sig_verified" | "verify_sigs" | "sigs_verified";
            } = {
                0: "none",
                1: "sign_request",
                2: "sign_result",
                3: "verify_sig",
                4: "sig_verified",
                5: "verify_sigs",
                6: "sigs_verified"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6])];
        }
        static fromObject(data: {
            sign_request?: ReturnType<typeof SignRequest.prototype.toObject>;
            sign_result?: ReturnType<typeof SignResult.prototype.toObject>;
            verify_sig?: ReturnType<typeof VerifySig.prototype.toObject>;
            sig_verified?: ReturnType<typeof SigVerified.prototype.toObject>;
            verify_sigs?: ReturnType<typeof VerifySigs.prototype.toObject>;
            sigs_verified?: ReturnType<typeof SigsVerified.prototype.toObject>;
        }): Event {
            const message = new Event({});
            if (data.sign_request != null) {
                message.sign_request = SignRequest.fromObject(data.sign_request);
            }
            if (data.sign_result != null) {
                message.sign_result = SignResult.fromObject(data.sign_result);
            }
            if (data.verify_sig != null) {
                message.verify_sig = VerifySig.fromObject(data.verify_sig);
            }
            if (data.sig_verified != null) {
                message.sig_verified = SigVerified.fromObject(data.sig_verified);
            }
            if (data.verify_sigs != null) {
                message.verify_sigs = VerifySigs.fromObject(data.verify_sigs);
            }
            if (data.sigs_verified != null) {
                message.sigs_verified = SigsVerified.fromObject(data.sigs_verified);
            }
            return message;
        }
        toObject() {
            const data: {
                sign_request?: ReturnType<typeof SignRequest.prototype.toObject>;
                sign_result?: ReturnType<typeof SignResult.prototype.toObject>;
                verify_sig?: ReturnType<typeof VerifySig.prototype.toObject>;
                sig_verified?: ReturnType<typeof SigVerified.prototype.toObject>;
                verify_sigs?: ReturnType<typeof VerifySigs.prototype.toObject>;
                sigs_verified?: ReturnType<typeof SigsVerified.prototype.toObject>;
            } = {};
            if (this.sign_request != null) {
                data.sign_request = this.sign_request.toObject();
            }
            if (this.sign_result != null) {
                data.sign_result = this.sign_result.toObject();
            }
            if (this.verify_sig != null) {
                data.verify_sig = this.verify_sig.toObject();
            }
            if (this.sig_verified != null) {
                data.sig_verified = this.sig_verified.toObject();
            }
            if (this.verify_sigs != null) {
                data.verify_sigs = this.verify_sigs.toObject();
            }
            if (this.sigs_verified != null) {
                data.sigs_verified = this.sigs_verified.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_sign_request)
                writer.writeMessage(1, this.sign_request, () => this.sign_request.serialize(writer));
            if (this.has_sign_result)
                writer.writeMessage(2, this.sign_result, () => this.sign_result.serialize(writer));
            if (this.has_verify_sig)
                writer.writeMessage(3, this.verify_sig, () => this.verify_sig.serialize(writer));
            if (this.has_sig_verified)
                writer.writeMessage(4, this.sig_verified, () => this.sig_verified.serialize(writer));
            if (this.has_verify_sigs)
                writer.writeMessage(5, this.verify_sigs, () => this.verify_sigs.serialize(writer));
            if (this.has_sigs_verified)
                writer.writeMessage(6, this.sigs_verified, () => this.sigs_verified.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Event {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Event();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.sign_request, () => message.sign_request = SignRequest.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.sign_result, () => message.sign_result = SignResult.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.verify_sig, () => message.verify_sig = VerifySig.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.sig_verified, () => message.sig_verified = SigVerified.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.verify_sigs, () => message.verify_sigs = VerifySigs.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.sigs_verified, () => message.sigs_verified = SigsVerified.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Event {
            return Event.deserialize(bytes);
        }
    }
    export class SignRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data?: SignedData;
            origin?: SignOrigin;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("origin" in data && data.origin != undefined) {
                    this.origin = data.origin;
                }
            }
        }
        get data() {
            return pb_1.Message.getWrapperField(this, SignedData, 1) as SignedData;
        }
        set data(value: SignedData) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_data() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get origin() {
            return pb_1.Message.getWrapperField(this, SignOrigin, 2) as SignOrigin;
        }
        set origin(value: SignOrigin) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_origin() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            data?: ReturnType<typeof SignedData.prototype.toObject>;
            origin?: ReturnType<typeof SignOrigin.prototype.toObject>;
        }): SignRequest {
            const message = new SignRequest({});
            if (data.data != null) {
                message.data = SignedData.fromObject(data.data);
            }
            if (data.origin != null) {
                message.origin = SignOrigin.fromObject(data.origin);
            }
            return message;
        }
        toObject() {
            const data: {
                data?: ReturnType<typeof SignedData.prototype.toObject>;
                origin?: ReturnType<typeof SignOrigin.prototype.toObject>;
            } = {};
            if (this.data != null) {
                data.data = this.data.toObject();
            }
            if (this.origin != null) {
                data.origin = this.origin.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_data)
                writer.writeMessage(1, this.data, () => this.data.serialize(writer));
            if (this.has_origin)
                writer.writeMessage(2, this.origin, () => this.origin.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data, () => message.data = SignedData.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.origin, () => message.origin = SignOrigin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignRequest {
            return SignRequest.deserialize(bytes);
        }
    }
    export class SignResult extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            signature?: Uint8Array;
            origin?: SignOrigin;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
                if ("origin" in data && data.origin != undefined) {
                    this.origin = data.origin;
                }
            }
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set signature(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get origin() {
            return pb_1.Message.getWrapperField(this, SignOrigin, 2) as SignOrigin;
        }
        set origin(value: SignOrigin) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_origin() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            signature?: Uint8Array;
            origin?: ReturnType<typeof SignOrigin.prototype.toObject>;
        }): SignResult {
            const message = new SignResult({});
            if (data.signature != null) {
                message.signature = data.signature;
            }
            if (data.origin != null) {
                message.origin = SignOrigin.fromObject(data.origin);
            }
            return message;
        }
        toObject() {
            const data: {
                signature?: Uint8Array;
                origin?: ReturnType<typeof SignOrigin.prototype.toObject>;
            } = {};
            if (this.signature != null) {
                data.signature = this.signature;
            }
            if (this.origin != null) {
                data.origin = this.origin.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signature.length)
                writer.writeBytes(1, this.signature);
            if (this.has_origin)
                writer.writeMessage(2, this.origin, () => this.origin.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.signature = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.origin, () => message.origin = SignOrigin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignResult {
            return SignResult.deserialize(bytes);
        }
    }
    export class VerifySig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data?: SignedData;
            signature?: Uint8Array;
            origin?: SigVerOrigin;
            node_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
                if ("origin" in data && data.origin != undefined) {
                    this.origin = data.origin;
                }
                if ("node_id" in data && data.node_id != undefined) {
                    this.node_id = data.node_id;
                }
            }
        }
        get data() {
            return pb_1.Message.getWrapperField(this, SignedData, 1) as SignedData;
        }
        set data(value: SignedData) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_data() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set signature(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get origin() {
            return pb_1.Message.getWrapperField(this, SigVerOrigin, 3) as SigVerOrigin;
        }
        set origin(value: SigVerOrigin) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_origin() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get node_id() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set node_id(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            data?: ReturnType<typeof SignedData.prototype.toObject>;
            signature?: Uint8Array;
            origin?: ReturnType<typeof SigVerOrigin.prototype.toObject>;
            node_id?: string;
        }): VerifySig {
            const message = new VerifySig({});
            if (data.data != null) {
                message.data = SignedData.fromObject(data.data);
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            if (data.origin != null) {
                message.origin = SigVerOrigin.fromObject(data.origin);
            }
            if (data.node_id != null) {
                message.node_id = data.node_id;
            }
            return message;
        }
        toObject() {
            const data: {
                data?: ReturnType<typeof SignedData.prototype.toObject>;
                signature?: Uint8Array;
                origin?: ReturnType<typeof SigVerOrigin.prototype.toObject>;
                node_id?: string;
            } = {};
            if (this.data != null) {
                data.data = this.data.toObject();
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            if (this.origin != null) {
                data.origin = this.origin.toObject();
            }
            if (this.node_id != null) {
                data.node_id = this.node_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_data)
                writer.writeMessage(1, this.data, () => this.data.serialize(writer));
            if (this.signature.length)
                writer.writeBytes(2, this.signature);
            if (this.has_origin)
                writer.writeMessage(3, this.origin, () => this.origin.serialize(writer));
            if (this.node_id.length)
                writer.writeString(4, this.node_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VerifySig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VerifySig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data, () => message.data = SignedData.deserialize(reader));
                        break;
                    case 2:
                        message.signature = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.origin, () => message.origin = SigVerOrigin.deserialize(reader));
                        break;
                    case 4:
                        message.node_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VerifySig {
            return VerifySig.deserialize(bytes);
        }
    }
    export class SigVerified extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            origin?: SigVerOrigin;
            node_id?: string;
            error?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("origin" in data && data.origin != undefined) {
                    this.origin = data.origin;
                }
                if ("node_id" in data && data.node_id != undefined) {
                    this.node_id = data.node_id;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get origin() {
            return pb_1.Message.getWrapperField(this, SigVerOrigin, 1) as SigVerOrigin;
        }
        set origin(value: SigVerOrigin) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_origin() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get node_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set node_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get error() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set error(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            origin?: ReturnType<typeof SigVerOrigin.prototype.toObject>;
            node_id?: string;
            error?: string;
        }): SigVerified {
            const message = new SigVerified({});
            if (data.origin != null) {
                message.origin = SigVerOrigin.fromObject(data.origin);
            }
            if (data.node_id != null) {
                message.node_id = data.node_id;
            }
            if (data.error != null) {
                message.error = data.error;
            }
            return message;
        }
        toObject() {
            const data: {
                origin?: ReturnType<typeof SigVerOrigin.prototype.toObject>;
                node_id?: string;
                error?: string;
            } = {};
            if (this.origin != null) {
                data.origin = this.origin.toObject();
            }
            if (this.node_id != null) {
                data.node_id = this.node_id;
            }
            if (this.error != null) {
                data.error = this.error;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_origin)
                writer.writeMessage(1, this.origin, () => this.origin.serialize(writer));
            if (this.node_id.length)
                writer.writeString(2, this.node_id);
            if (this.error.length)
                writer.writeString(3, this.error);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SigVerified {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SigVerified();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.origin, () => message.origin = SigVerOrigin.deserialize(reader));
                        break;
                    case 2:
                        message.node_id = reader.readString();
                        break;
                    case 3:
                        message.error = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SigVerified {
            return SigVerified.deserialize(bytes);
        }
    }
    export class VerifySigs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data?: SignedData[];
            signatures?: Uint8Array[];
            origin?: SigVerOrigin;
            node_ids?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("signatures" in data && data.signatures != undefined) {
                    this.signatures = data.signatures;
                }
                if ("origin" in data && data.origin != undefined) {
                    this.origin = data.origin;
                }
                if ("node_ids" in data && data.node_ids != undefined) {
                    this.node_ids = data.node_ids;
                }
            }
        }
        get data() {
            return pb_1.Message.getRepeatedWrapperField(this, SignedData, 1) as SignedData[];
        }
        set data(value: SignedData[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get signatures() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as Uint8Array[];
        }
        set signatures(value: Uint8Array[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get origin() {
            return pb_1.Message.getWrapperField(this, SigVerOrigin, 3) as SigVerOrigin;
        }
        set origin(value: SigVerOrigin) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_origin() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get node_ids() {
            return pb_1.Message.getFieldWithDefault(this, 4, []) as string[];
        }
        set node_ids(value: string[]) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            data?: ReturnType<typeof SignedData.prototype.toObject>[];
            signatures?: Uint8Array[];
            origin?: ReturnType<typeof SigVerOrigin.prototype.toObject>;
            node_ids?: string[];
        }): VerifySigs {
            const message = new VerifySigs({});
            if (data.data != null) {
                message.data = data.data.map(item => SignedData.fromObject(item));
            }
            if (data.signatures != null) {
                message.signatures = data.signatures;
            }
            if (data.origin != null) {
                message.origin = SigVerOrigin.fromObject(data.origin);
            }
            if (data.node_ids != null) {
                message.node_ids = data.node_ids;
            }
            return message;
        }
        toObject() {
            const data: {
                data?: ReturnType<typeof SignedData.prototype.toObject>[];
                signatures?: Uint8Array[];
                origin?: ReturnType<typeof SigVerOrigin.prototype.toObject>;
                node_ids?: string[];
            } = {};
            if (this.data != null) {
                data.data = this.data.map((item: SignedData) => item.toObject());
            }
            if (this.signatures != null) {
                data.signatures = this.signatures;
            }
            if (this.origin != null) {
                data.origin = this.origin.toObject();
            }
            if (this.node_ids != null) {
                data.node_ids = this.node_ids;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data.length)
                writer.writeRepeatedMessage(1, this.data, (item: SignedData) => item.serialize(writer));
            if (this.signatures.length)
                writer.writeRepeatedBytes(2, this.signatures);
            if (this.has_origin)
                writer.writeMessage(3, this.origin, () => this.origin.serialize(writer));
            if (this.node_ids.length)
                writer.writeRepeatedString(4, this.node_ids);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VerifySigs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VerifySigs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SignedData.deserialize(reader), SignedData));
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readBytes());
                        break;
                    case 3:
                        reader.readMessage(message.origin, () => message.origin = SigVerOrigin.deserialize(reader));
                        break;
                    case 4:
                        pb_1.Message.addToRepeatedField(message, 4, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VerifySigs {
            return VerifySigs.deserialize(bytes);
        }
    }
    export class SigsVerified extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            origin?: SigVerOrigin;
            node_ids?: string[];
            errors?: string[];
            all_ok?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("origin" in data && data.origin != undefined) {
                    this.origin = data.origin;
                }
                if ("node_ids" in data && data.node_ids != undefined) {
                    this.node_ids = data.node_ids;
                }
                if ("errors" in data && data.errors != undefined) {
                    this.errors = data.errors;
                }
                if ("all_ok" in data && data.all_ok != undefined) {
                    this.all_ok = data.all_ok;
                }
            }
        }
        get origin() {
            return pb_1.Message.getWrapperField(this, SigVerOrigin, 1) as SigVerOrigin;
        }
        set origin(value: SigVerOrigin) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_origin() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get node_ids() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set node_ids(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get errors() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set errors(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get all_ok() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set all_ok(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            origin?: ReturnType<typeof SigVerOrigin.prototype.toObject>;
            node_ids?: string[];
            errors?: string[];
            all_ok?: boolean;
        }): SigsVerified {
            const message = new SigsVerified({});
            if (data.origin != null) {
                message.origin = SigVerOrigin.fromObject(data.origin);
            }
            if (data.node_ids != null) {
                message.node_ids = data.node_ids;
            }
            if (data.errors != null) {
                message.errors = data.errors;
            }
            if (data.all_ok != null) {
                message.all_ok = data.all_ok;
            }
            return message;
        }
        toObject() {
            const data: {
                origin?: ReturnType<typeof SigVerOrigin.prototype.toObject>;
                node_ids?: string[];
                errors?: string[];
                all_ok?: boolean;
            } = {};
            if (this.origin != null) {
                data.origin = this.origin.toObject();
            }
            if (this.node_ids != null) {
                data.node_ids = this.node_ids;
            }
            if (this.errors != null) {
                data.errors = this.errors;
            }
            if (this.all_ok != null) {
                data.all_ok = this.all_ok;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_origin)
                writer.writeMessage(1, this.origin, () => this.origin.serialize(writer));
            if (this.node_ids.length)
                writer.writeRepeatedString(2, this.node_ids);
            if (this.errors.length)
                writer.writeRepeatedString(3, this.errors);
            if (this.all_ok != false)
                writer.writeBool(4, this.all_ok);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SigsVerified {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SigsVerified();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.origin, () => message.origin = SigVerOrigin.deserialize(reader));
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    case 4:
                        message.all_ok = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SigsVerified {
            return SigsVerified.deserialize(bytes);
        }
    }
    export class SignOrigin extends pb_1.Message {
        #one_of_decls: number[][] = [[2, 4]];
        constructor(data?: any[] | ({
            module?: string;
        } & (({
            context_store?: dependency_1.contextstorepb.Origin;
            dsl?: never;
        } | {
            context_store?: never;
            dsl?: dependency_2.dslpb.Origin;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("module" in data && data.module != undefined) {
                    this.module = data.module;
                }
                if ("context_store" in data && data.context_store != undefined) {
                    this.context_store = data.context_store;
                }
                if ("dsl" in data && data.dsl != undefined) {
                    this.dsl = data.dsl;
                }
            }
        }
        get module() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set module(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get context_store() {
            return pb_1.Message.getWrapperField(this, dependency_1.contextstorepb.Origin, 2) as dependency_1.contextstorepb.Origin;
        }
        set context_store(value: dependency_1.contextstorepb.Origin) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_context_store() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get dsl() {
            return pb_1.Message.getWrapperField(this, dependency_2.dslpb.Origin, 4) as dependency_2.dslpb.Origin;
        }
        set dsl(value: dependency_2.dslpb.Origin) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_dsl() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get type() {
            const cases: {
                [index: number]: "none" | "context_store" | "dsl";
            } = {
                0: "none",
                2: "context_store",
                4: "dsl"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2, 4])];
        }
        static fromObject(data: {
            module?: string;
            context_store?: ReturnType<typeof dependency_1.contextstorepb.Origin.prototype.toObject>;
            dsl?: ReturnType<typeof dependency_2.dslpb.Origin.prototype.toObject>;
        }): SignOrigin {
            const message = new SignOrigin({});
            if (data.module != null) {
                message.module = data.module;
            }
            if (data.context_store != null) {
                message.context_store = dependency_1.contextstorepb.Origin.fromObject(data.context_store);
            }
            if (data.dsl != null) {
                message.dsl = dependency_2.dslpb.Origin.fromObject(data.dsl);
            }
            return message;
        }
        toObject() {
            const data: {
                module?: string;
                context_store?: ReturnType<typeof dependency_1.contextstorepb.Origin.prototype.toObject>;
                dsl?: ReturnType<typeof dependency_2.dslpb.Origin.prototype.toObject>;
            } = {};
            if (this.module != null) {
                data.module = this.module;
            }
            if (this.context_store != null) {
                data.context_store = this.context_store.toObject();
            }
            if (this.dsl != null) {
                data.dsl = this.dsl.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.module.length)
                writer.writeString(1, this.module);
            if (this.has_context_store)
                writer.writeMessage(2, this.context_store, () => this.context_store.serialize(writer));
            if (this.has_dsl)
                writer.writeMessage(4, this.dsl, () => this.dsl.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignOrigin {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignOrigin();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.module = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.context_store, () => message.context_store = dependency_1.contextstorepb.Origin.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.dsl, () => message.dsl = dependency_2.dslpb.Origin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignOrigin {
            return SignOrigin.deserialize(bytes);
        }
    }
    export class SigVerOrigin extends pb_1.Message {
        #one_of_decls: number[][] = [[2, 4]];
        constructor(data?: any[] | ({
            module?: string;
        } & (({
            context_store?: dependency_1.contextstorepb.Origin;
            dsl?: never;
        } | {
            context_store?: never;
            dsl?: dependency_2.dslpb.Origin;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("module" in data && data.module != undefined) {
                    this.module = data.module;
                }
                if ("context_store" in data && data.context_store != undefined) {
                    this.context_store = data.context_store;
                }
                if ("dsl" in data && data.dsl != undefined) {
                    this.dsl = data.dsl;
                }
            }
        }
        get module() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set module(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get context_store() {
            return pb_1.Message.getWrapperField(this, dependency_1.contextstorepb.Origin, 2) as dependency_1.contextstorepb.Origin;
        }
        set context_store(value: dependency_1.contextstorepb.Origin) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_context_store() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get dsl() {
            return pb_1.Message.getWrapperField(this, dependency_2.dslpb.Origin, 4) as dependency_2.dslpb.Origin;
        }
        set dsl(value: dependency_2.dslpb.Origin) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_dsl() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get type() {
            const cases: {
                [index: number]: "none" | "context_store" | "dsl";
            } = {
                0: "none",
                2: "context_store",
                4: "dsl"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2, 4])];
        }
        static fromObject(data: {
            module?: string;
            context_store?: ReturnType<typeof dependency_1.contextstorepb.Origin.prototype.toObject>;
            dsl?: ReturnType<typeof dependency_2.dslpb.Origin.prototype.toObject>;
        }): SigVerOrigin {
            const message = new SigVerOrigin({});
            if (data.module != null) {
                message.module = data.module;
            }
            if (data.context_store != null) {
                message.context_store = dependency_1.contextstorepb.Origin.fromObject(data.context_store);
            }
            if (data.dsl != null) {
                message.dsl = dependency_2.dslpb.Origin.fromObject(data.dsl);
            }
            return message;
        }
        toObject() {
            const data: {
                module?: string;
                context_store?: ReturnType<typeof dependency_1.contextstorepb.Origin.prototype.toObject>;
                dsl?: ReturnType<typeof dependency_2.dslpb.Origin.prototype.toObject>;
            } = {};
            if (this.module != null) {
                data.module = this.module;
            }
            if (this.context_store != null) {
                data.context_store = this.context_store.toObject();
            }
            if (this.dsl != null) {
                data.dsl = this.dsl.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.module.length)
                writer.writeString(1, this.module);
            if (this.has_context_store)
                writer.writeMessage(2, this.context_store, () => this.context_store.serialize(writer));
            if (this.has_dsl)
                writer.writeMessage(4, this.dsl, () => this.dsl.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SigVerOrigin {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SigVerOrigin();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.module = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.context_store, () => message.context_store = dependency_1.contextstorepb.Origin.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.dsl, () => message.dsl = dependency_2.dslpb.Origin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SigVerOrigin {
            return SigVerOrigin.deserialize(bytes);
        }
    }
    export class SignedData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            data?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
            }
        }
        get data() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as Uint8Array[];
        }
        set data(value: Uint8Array[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            data?: Uint8Array[];
        }): SignedData {
            const message = new SignedData({});
            if (data.data != null) {
                message.data = data.data;
            }
            return message;
        }
        toObject() {
            const data: {
                data?: Uint8Array[];
            } = {};
            if (this.data != null) {
                data.data = this.data;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data.length)
                writer.writeRepeatedBytes(1, this.data);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignedData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignedData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignedData {
            return SignedData.deserialize(bytes);
        }
    }
}
